// Package aesebc implements a simples libary
// for AES algorithm with EBC mode.
package aesebc

import (
	"bytes"
	"crypto/aes"
	"errors"
)

// ZeroPadding pads byte array to block size with zero
func ZeroPadding(data []byte, blockSize int) []byte {
	padding := blockSize - len(data)%blockSize
	padText := bytes.Repeat([]byte{0}, padding)
	return append(data, padText...)
}

// ZeroUnPadding removes zero padding
func ZeroUnPadding(data []byte) ([]byte, error) {
	padding := 0
	length := len(data)
	if length == 0 {
		return nil, errors.New("cannot remove padding for zero length byte array")
	}
	for i := length - 1; i >= 0; i-- {
		// byte is same to int8, stands for ascii code
		if data[i] == 0 {
			padding++
		} else {
			break
		}
	}
	return data[:length-padding], nil
}

// AesEncrypt function encrypt plaintext by AES ECB mode
func AesEncrypt(plainText []byte, key []byte) []byte {
	block, _ := aes.NewCipher(key)
	blockSize := block.BlockSize()
	plainTextPadding := ZeroPadding(plainText, blockSize)

	cipherByte := make([]byte, len(plainTextPadding))
	for start, end := 0, blockSize; start < len(plainTextPadding); start, end = start+blockSize, end+blockSize {
		block.Encrypt(cipherByte[start:end], plainTextPadding[start:end])
	}

	return cipherByte
}

// AesDecrypt function decrypt plaintext by AES ECB mode
func AesDecrypt(cipherText []byte, key []byte) []byte {
	// create an AES instance
	block, _ := aes.NewCipher(key)
	blockSize := block.BlockSize()

	cipherText = ZeroPadding(cipherText, blockSize)
	plainByte := make([]byte, len(cipherText))
	for start, end := 0, blockSize; start < len(cipherText); start, end = start+blockSize, end+blockSize {
		block.Decrypt(plainByte[start:end], cipherText[start:end])
	}

	plainByte, _ = ZeroUnPadding(plainByte)
	return plainByte
}
